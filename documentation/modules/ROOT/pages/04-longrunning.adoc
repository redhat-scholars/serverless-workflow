= Long Running Workflows

include::_attributes.adoc[]

Having a graphical notation to orchestrate services is nice, but you might wonder if it is worth it!

The real power of a workflow engine gets into action when the process is long running: in other words, when it reaches a pause status, because it has to wait an asynchronous event, a manual intervention, a timer.

In this section, you will evolve the workflow to add this long running nature!

[#waitevent]
== Wait an event

From a use case perspective, the workflow has to wait for *shipment procedure completion* event.
For sake of simplicity, let's imagine that an external integration service is able to homogenize events arriving from the internal department and those arriving from the external supplier.

The event will bring an important information the *correlation key*, in our use case is the `orderId`.
As the name implies, the correlation key is important to address the correct workflow instance.

The *correlation key MUST BE initialized* at creation time with an incoming *Cloud Event*.

This implies two _catching event nodes_ are required:

* one at the beginning of the flow to start the workflow
* another after the `Prepare for Shipping` and `Forward to External Supplier` to wait the shipping event

//-

1. Define the event types
+
[.console-input]
[source, json,subs="+macros,+attributes"]
----
"events": [
  {
    "name": "orderEvent",
    "kind": "consumed",
    "type": "OrderEventType",
    "source": "Client",
    "correlation": [
      {
        "contextAttributeName": "orderid"
      }
    ]
  },
  {
    "name": "shippingEvent",
    "kind": "consumed",
    "type": "ShippingEventType",
    "source": "Shipper",
    "correlation": [
      {
        "contextAttributeName": "orderid"
      }
    ]
  }
],
----
+
The definition is quite self explanatory: the workflow can *consume* to different *types of events* `OrderEventType` and `ShippingEventType`, from two different *sources*. 
One important aspect is the _correlation definition_ which says that _Cloud Event_ has to carry a special *attribute in the header* named `orderid`.

2. *Add* an _event node_ after the start node
+
[.console-input]
[source, json,subs="+macros,+attributes"]
----
{
  "name": "Order Received",
  "type": "event",
  "onEvents": [
    {
      "eventRefs": [
        "orderEvent"
      ]
    }
  ],
  "transition": "Check Inventory"
}
----

3. *Update* the _start_ attribute to match the event state `Order Received`, this is the graphical outcome:
+
image::order-received.png[]

4. *Add* another _event node_ at the end:

* name: `Order Shipped`
* eventRef: `shippingEvent`

5. *Update* `Prepare for Shipping` and `Forward to External Supplier` to *transition* in `Order Shipped` event node

