= Long Running Workflows

include::_attributes.adoc[]

Having a graphical notation to orchestrate services is nice, but you might wonder if it is worth it!

The real power of a workflow engine gets into action when the workflow is *long running*: in other words, when it reaches a pause status, because it has to wait an asynchronous event, a manual intervention or a timer.

In this section, you will evolve the workflow to add this long running nature!

From a use case perspective, the workflow has to wait for an _asynchronous_ event which confirms the completion *shipment procedures*. 

The following picture shows an high level design: 

image:high-level-flow-2.png[]

[#waitevent]
== Wait Event Sprint

For sake of simplicity, let's imagine that an external integration service is able to homogenize events arriving from the internal department and those arriving from the external supplier.

The event will bring an important information the *correlation key*, in our use case is the `orderId`.
As the name implies, the correlation key is important to address the correct workflow instance.

The *correlation key MUST BE initialized* at creation time with an incoming *CloudEvent*.

This implies two _catching event nodes_ are required:

* one at the beginning of the flow to start the workflow

* another after the `Prepare for Shipping` and `Forward to External Supplier` to wait the shipping event

//-
Open the workflow editor and follow these steps:

. Before the `start` declaration, *add* the following _event declaration_:
+
[.console-input]
[source,yaml,subs="+macros,+attributes"]
----
events:
- name: orderEvent
  kind: consumed
  type: OrderEventType
  source: Client
  correlation:
  - contextAttributeName: orderid
- name: shippingEvent
  kind: consumed
  type: ShippingEventType
  source: Shipper
  correlation:
  - contextAttributeName: orderid
----
+
The definition is quite self explanatory: the workflow can *consume* two different *types of events*: `OrderEventType` and `ShippingEventType`, from two different *sources*. 
One important aspect is the _correlation definition_ which says that _CloudEvent_ has to carry a special *attribute in the header* named `orderid` (CloudEvents attributes must be _lowercase_).

. Add an *_event state_* at the beginning of the workflow:

.. *Insert* the following immediately after the declaration of `states`:
+
[.console-input]
[source,yaml,subs="+macros,+attributes"]
----
- name: Order Received
  type: event
  onEvents:
    - eventRefs:
        - orderEvent
  transition: Check Inventory
----

.. *Update* the `start` attribute to match the event state `Order Received`, this is the graphical outcome:
+
image::04_order-received.png[]

. Add another *_event state_* at the end of the workflow:

.. *Insert* another _event_ state declaration:

* name: `Order Shipped`
* eventRef: `shippingEvent`

+
+
NOTE: It's worth noting that the order of the declarations is irrelevant, but to make the file easier to read, it's a good practice to follow the same order in the textual representation as in the graphical one.

.. *Update* the `Prepare for Shipping` and `Forward to External Supplier` states to *transition* in the `Order Shipped` event node; on both declarations:

... remove `end: true`
... add `transition: Order Shipped`

+
The resulting diagram is:

+
image::04_order-shipped.png[order shipped]

. To complete the use case implementation, you have to add another operation that is responsible of *notifying* the customer about the shipping status with usual tracking information:

* *copy* the previous operation state `Prepare for Shipping`
* *rename* it to `Notify Customer`
* *update* the message to match the operation name
* *remove* the existing _transition_ and *add* the attribute `end: true`

. *Update* the previous `Order Shipped` event state *adding* the _transition_ to `Notify Customer`

:sol-stage: 03-long-wait
include::partial$sync-project.adoc[]
:!sol-stage:

[#eventing]
== Eventing

Events in Serverless Workflow comply to the https://cloudevents.io/[CloudEvents] standard which is under the https://cncf.io[Cloud Native Computing Foundation].

Moreover, Serverless Workflow, and in general *OpenShift Serverless Logic*, aims to fit seamlessly in https://knative.dev/docs/eventing[Knative eventing].

For such a reason, Serverless Workflow exposes two channels to ingest _CloudEvents_:

* HTTP POST
* Kafka Broker

The developer runtime listens for _CloudEvents_ on the root path of the standard HTTP channel (e.g. `http:/localhost:8080/`).
In general, the Serverless Workflow runtime can expose multiple endpoints to ingest different types of events.

[#test-events]
== Test the events

To _start_ the workflow and subsequently _advance_ it, you have to inject two *types* of _CloudEvent_:

* `OrderEventType`
* `ShippingEventType`

The Dev UI offers a convenient web form to inject _CloudEvents_ in the Serverless Workflow runtime:

. *Open* the `Workflow Definitions` page.

. In workflow list, *click* on the event icon:

+
image::04_cloud-event.png[cloud event button]

. *Fill in* the form with the following values:

- *Event Type* : `OrderEventType`

- *Event Custom Headers* : `ce-orderid = 1000`

+
+
image::04_ce-header.png[custom event header]

- *Event Data* : `{"orderId": "1000", "item": "1111"}`

. *Click* `Trigger`

IMPORTANT: The CloudEvent is sent via the HTTP protocol, and by convention the CloudEvent attributes are sent as an HTTP header with a `ce-` prefix.
The *CloudEvent attribute* `orderid` matches the `contextAttributeName` used in the event definition for correlation. In other words, `orderid` is the hook to the workflow instance, you can run multiple workflow instances in parallel, but they must wait for a distinct `orderid`.

Open the *_Workflow Details_* page to inspect the instance status: you should see the the workflow instance still active, waiting for the shipping event:

image:04_shipping.png[Shipping Event]

To advance the workflow execution, you have to send another event:

. *Open* the `Workflow Definitions` page.

. In workflow list, *click* on the event icon:

+
image::04_cloud-event.png[cloud event button]

. *Fill in* the form with the following values:

- *Event Type* : `ShippingEventType`

- *Event Custom Headers* : `ce-orderid = 1000`

. *Click* `Trigger`

Use the *_Workflow Details_* page to check that the workflow instance is correctly completed.

**CONGRATULATION!!!** Your Serverless Workflow resumes when asynchronous events arrives!