= Inventory Logic
include::_attributes.adoc[]

In this section, you will expand the workflow logic to manage a first stage of fictional use case.

[#usecase]
== The use case

NOTE: As any other tutorial use case, the situation we are going to consider is somewhat realistic, but for sake of simplicity we are going to oversee many _real_ aspects. The primary goal is to show the key capabilities of the Serverless Workflow specification, please, apologise for the many naiveties that domain experts can easily point out.

An e-commerce company has to implement the following **order management** workflow: 

* When a new order come in, they need to **check the inventory** for the availability of the items. If the items are available the order will be **prepared for shipping** (picking, packaging, printing label, etc), when the shipping is completed, the shipping department send an event back to the workflow and the customer is **notified** about the shipping status with usual tracking information.

* If the item is out of stock, the order will be forwarded to a **external supplier** who will take care of the shipping procedure, when the **supplier ships** the order, it also send an event back to the workflow, in such a way the workflow can continue and **send the notification** to the customer.

* As long as the order is not shipped, the customer has the option of **cancelling the order** by also cancelling the shipping.

The following picture shows an high level design: 

image::high-level-flow.png[]

:sprint-note: pass:c,q[footnote:disclaimer[A Sprint is an iteration in the Agile methodology, which aims to be time-boxed, self container and always executable.]]

The final use case will be implemented going through a set consecutive _sprints_{sprint-note}, in every sprint you are going to experience a new feature of the Serverless Workflow specification.


[#inventory]
== The Inventory Sprint

In this sprint we are going to add the **check inventory** operation and based on the outcome call a **prepare for shipping** or **forward to external supplier**.

Switch back to the *Serverless Logic Web Tools* to edit the `order` workflow:

. **Rename** the first state from `Order Received` to `Check Inventory` updating the following places:

* the `start` value
* state `name`
* the `message` content

+
TIP: To change all occurrences in one shot: select `Order Received`, press twice `CTRL-D`, perform the rename, then press `ESC`

. In the `Check Inventory` state, **add** the following definition just after the `functionRef` object (at the same level):
+
[.console-input]
[source, json,subs="+macros,+attributes"]
----
        actionDataFilter:
          fromStateData: .
          results: '{inventory: .item | test("0+") }'
----
+
This code mocks up the check inventory logic: `actionDataFilter` is a feature to manipulate the workflow data (state scoped), in practical terms it gets the `item` value and create a new data `inventory` which value can be _true_ or _false_ if the `item` contains one or more `0`
+
TIP: The previous logic is an example of the **JQ expression language** which plays a key role in Serverless Workflow. To evaluate and manipulate data is crucial to gaining some familiarity with this language https://openshift-knative.github.io/docs/docs/latest/serverless-logic/core/understanding-jq-expressions.html[Understanding JQ expressions]

. Introduce a new switch state after the previous state:

.. *Move the cursor* to the end of yaml file at state level and *type* ```- ``` (a dash followed by a space) and you should get the suggestion pop up, *hit* `Enter` to confirm the suggestion.
+
image::03_suggest.png[new switch state]

.. *Update* the template keys `name` and `condition` as in the following snippet:
+
[.console-input]
[source,yaml,subs="+macros,+attributes"]
----
  - name: 'Item Available?'
    type: switch
    dataConditions:
      - condition: '.inventory'
        transition: 'Transition to another state if condition is true'
    defaultCondition:
      transition: 'Default transition of the workflow'
----

.. Go back to `Check Inventory` state and **replace** the `end` declaration with transition to point to the switch state:
+
[.console-input]
[source,yaml,subs="+macros,+attributes"]
----
transition: Item Available?
----

. After the switch, you have to add other two states:

.. **Add** a new operation state for `Prepare for Shipping`:
+
[.console-input]
[source, yaml,subs="+macros,+attributes"]
----
  - name: 'Prepare for Shipping'
    type: operation
    actions:
      - name: printAction
        functionRef:
          refName: printMessage
          arguments:
            message: Prepare for Shipping
    end: true
----

.. **Add** an new operation state for `Forward to External Supplier`:
+
[.console-input]
[source, yaml,subs="+macros,+attributes"]
----
  - name: 'Forward to External Supplier'
    type: operation
    actions:
      - name: printAction
        functionRef:
          refName: printMessage
          arguments:
            message: Forward to External Supplier
    end: true
----

. **Update** the switch state to point to the correct operation states:

.. for the conditional branch set the transition to `Prepare for Shipping`
+
image::03_condition.png[]

.. for the default condition set the transition to `Forward to External Supplier`

The workflow diagram should now resemble the following:

image::03_wf_switch.png[]

:sol-stage: 01-inventory
include::partial$sync-project.adoc[]
:!sol-stage:

[#test]
== Test the workflow logic

Before connecting the workflow to an external service is a good idea to probe it in isolation (i.e. smoke test): in fact, the current actions only print messages in the console.

. *Deploy* the current workflow:

.. *Select* `Try on OpenShift` button and then `Upload "*order*" to Dev Mode`.
+
image::02_upload.png[upload]

.. Wait for the confirmation message and *select* `Go to Serverless Workflow Dev UI â†—` to open the _Dev UI_ in a new browser tab.
+
image::02_devui.png[Dev UI]

. *Trigger* a new workflow instance:

.. *Select* `Workflow Definitions`

.. *Click* on the arrow button in corresponding to the `order` row.
+
image::02_wf-def.png[Workflow definitions]

.. *Fill* in the `Start Workflow Data` edit box with the following JSON payload:
+
[.console-input]
[source,json,subs="+macros,+attributes"]
----
{
    "orderId": "1000",
    "item": "1110"
}
----

.. *Select* the `Start` button below.

. *Check* the results and the workflow execution:

.. *Switch* to the _Workflow Instances_ page

.. *Click* on the latest instance to show the _Workflow Details_ page

. *Trigger* a new workflow instance with the following payload and make sure that the workflow execution follow the other branch (`Forward to External Supplier`)
+
[.console-input]
[source,json,subs="+macros,+attributes"]
----
{
    "orderId": "1001",
    "item": "1111"
}
----

Another tool for checking the workflow execution is the *Console*:

. At the bottom of the _Dev UI_, *click* on the `Open` toggle.
+
image::03_open_con.png[open console]

. Among other log lines, you should spot the output of `printMessage`:
+
image::03_console.png[console]


[#call-rest]
== Call an external REST service

Serverless Workflow have a straightforward integration with OpenAPIs.

In order to experiment this capability, we'll use a side application called `order-swf-tut-svc` that exposes two simple REST operations:

* `sendOrder` to send order to a supplier
* `cancelOrder` to send an order cancellation to a supplier

NOTE: `order-swf-tut-svc` application should be already deployed in the `swf-shared` namespace. However, if it's not the case, you'll find direction on how to deploy it in the xref:01-setup.adoc[Setup] chapter.

The link between the workflow and the rest service is the *OpenAPIs spec file* that should be located inside the `specs` folder.

For sake of simplicity, you will import a project that contains all the required files: the workflow yaml, the OpenAPI spec and the `application.property` file. The latter contains information about the REST service endpoint.

. Open the https://start.kubesmarts.org/[Serverless Logic Web Tools] in your browser (if you already have it in your browser window, make sure to click on the top banner to open the home page).

. Locate the `Import` box in the page and *copy* the following address in the URL field: `https://github.com/dmarrazzo/order-swf-tut.git`

. *Click* the `Clone` button

The tool will take you to the Serverless Workflow designer, but you can switch to the other files in the project by clicking the arrow next the file name:

image::03_repo_nav.png[repository navigation]

In the following steps, you'll enhance the workflow design to call an external service:

. *Add* the OpenAPI references in the `functions` declaration section:
+
[.console-input]
[source,yaml,subs="+macros,+attributes"]
----
- name: sendOrder
  operation: specs/supplier.yaml#sendOrder
  type: rest
- name: cancelOrder
  operation: specs/supplier.yaml#cancelOrder
  type: rest
----

. *Locate* the `Forward to External Supplier` state declaration.
+
TIP: You can click on state in the workflow diagram and the tool will take the cursor to the declaration line in the yaml editor.

. *Replace* `printAction` with `sendOrder`:
+
[.console-input]
[source,yaml,subs="+macros,+attributes"]
----
  actions:
  - name: sendOrder
    functionRef:
      refName: sendOrder
      arguments:
        supplier-id: sup-01
        content: '.orderId'
----
+
NOTE: The rest service is invoked with two _arguments_, a dummy `supplier-id` (`sup-01`) and the value of `orderId`.

[#test-rest]
== Test the external REST service

In order to test the REST call you have to *trigger* a new workflow instance with the following payload:

[.console-input]
[source,json,subs="+macros,+attributes"]
----
{
    "orderId": "1002",
    "item": "1111"
}
----

In the log file you should notice a different output coming from the REST implementation:

[.console-output]
[source, bash,subs="+macros,+attributes"]
----
Triggered node 'Forward to External Supplier' for process 'order' (0ce6279c-2e84-42d0-b651-5e7b5257ef74)
Triggered node 'sendOrder' for process 'order' (0ce6279c-2e84-42d0-b651-5e7b5257ef74)
Property 'workflowdata.response' changed value from: 'null', to: '"receipt-sup-01-1002"'
----

Finally, *open* the _workflow instance details_ and pay attention to a new variable which is injected by the REST service response:

image::03_response.png[response variable]

**CONGRATULATION!!!** Now your Serverless Workflow call a REST service!